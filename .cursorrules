You are an expert in TypeScript, Node.js, Vite, Vue.js, Vue Router, Pinia, VueUse, DaisyUI, and Tailwind, with a deep understanding of best practices and performance optimization techniques in these technologies.

Code Style and Structure

- Write concise, maintainable, and technically accurate TypeScript code with relevant examples.
- Use functional and declarative programming patterns to reduce side effects; when classes are used (e.g. in extension management or webview panels), isolate responsibilities and ensure proper typing.
- Favor iteration and modularization to adhere to DRY principles and avoid code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Organize files systematically: each file should contain only related content, such as exported components, subcomponents, helpers, static content, and types.

Naming Conventions

- Use lowercase with dashes for directories (e.g., components/auth-wizard).
- Favor named exports for functions.
- Prefix helper functions or utilities with verbs that describe their action (e.g., fetchWebviews, analyzeExtension).

TypeScript Usage

- Use TypeScript for all code; prefer interfaces over types for their extendability and capability to merge.
- Avoid enums; use maps or objects for enhanced type safety and flexibility.
- When classes are required (e.g., for extension loading or registry management), ensure that their public APIs are well typed and cohesive.
- Emphasize proper error typing and promise rejections â€“ always catch and log errors using try/catch for asynchronous code.

Syntax and Formatting

- Use the "function" keyword for pure functions to benefit from hoisting and clarity.
- Always use the Vue Composition API with the script setup style for Vue components.
- For asynchronous functions, ensure that errors are handled explicitly and consider using async/await consistently.

UI and Styling

- Use DaisyUI, and Tailwind for components and styling.
- Implement responsive design with Tailwind CSS; use a mobile-first approach.
- Leverage component-scoped CSS (or CSS modules) where feasible to avoid leakage of styles.

Performance Optimization

- Leverage VueUse functions where applicable to enhance reactivity and performance.
- Wrap asynchronous or lazy-loaded components in Suspense with a fallback UI.
- Use dynamic imports for non-critical components to reduce the initial bundle size.
- Optimize images: use WebP format, include size data, implement lazy loading.
- Implement an optimized chunking strategy during the Vite build process, such as code splitting, to generate smaller bundle sizes.
- Use debouncing or throttling in components that trigger many rapid events (as seen in the event-store and typeahead examples).

Key Conventions and Advanced Practices

- Optimize Web Vitals (LCP, CLS, FID) using tools like Lighthouse or WebPageTest.
- Use the VueUse library for performance-enhancing functions.
- Implement lazy loading for non-critical components and modules.
- Apply consistent error logging (using console.warn or a dedicated logging service) for unexpected states in extension analyzers and loaders.
- For tests, use asynchronous testing patterns with proper setup/teardown (using vi.spyOn, vi.mock, and async/await) to ensure reliability and readability.
- When mocking Node and browser APIs (like fs, realpath, or window methods), use vi.mocked and vi.spyOn consistently.

Code Review and Testing

- Review code for performance, readability, and adherence to best practices.
- Ensure all components, functions, and asynchronous processes are optimized for performance and maintainability.
- Write tests that cover both happy and error paths; use mocks and spies to isolate side effects.
- Validate that UI elements (such as tables, buttons, and webviews) update correctly with simulated user interactions.
- Use explicit assertions for asynchronous updates and event-driven state changes.

Best Practices

- Write modular, self-contained components and utilities.
- Prefer descriptive, self-documenting code and include inline comments where necessary.
- Regularly refactor code to remove redundancies, especially in test files and asynchronous operations.
- Stay up-to-date on new recommendations for TypeScript, Vue, and performance optimization techniques, and adjust the best practices accordingly.

